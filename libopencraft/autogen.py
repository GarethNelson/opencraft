import json
from quarry.data import packets as q_packets

fd = open('burger_data/1.11.json','rb')
json_data = json.loads(fd.read().strip('\n'))
fd.close()

packets_fields = {}

for k,v in json_data[0]['packets']['packet'].items():
    protover  = 315
    protomode = v['state'].lower()
    if v['direction']=='CLIENTBOUND':
       packdir='downstream'
    else:
       packdir='upstream'
    pack_id = v['id']
    key = (protover,protomode,packdir,pack_id)
    packet_name = 'unknown_%s_%s_%s' % (packdir,protomode,pack_id)
    if q_packets.packet_names.has_key(key):
       packet_name = q_packets.packet_names[key]
    packfields = []
    for field in v['instructions']:
        if field.has_key('type'):
           packfields.append(field['type'])
        else:
           packfields.append('bytes')
    k = '%s_%s_%s' % (packet_name,protomode,packdir)
    packets_fields[k] = packfields

alphabet ='abcdefghijklmnopqrstuvwxyz'

print "// AUTOGENERATED - See autogen.py, do not modify directly"
print "#pragma once"

mctypes = {'boolean' :'bool',
           'byte'    :'char',
           'byte[]'  :'char*',
           'char'    :'char',
           'string16':'std::string',
           'double'  :'double',
           'float'   :'float',
           'int'     :'int32_t',
           'long'    :'int64_t',
           'short'   :'int16_t',
           'string8' :'std::string',
           'varint'  :'int32_t',
           'position':'std::tuple<float,float,float>',
           'enum'    :'int32_t',
           'bytes'   :'char*'}

print "namespace opencraft_packets {"
for k,v in packets_fields.items():
    skip = False
    params = []
    for f in xrange(len(v)):
        if not mctypes.has_key(v[f]):
           print '// WARNING: Can not autogenerate %s due to missing type %s ' % (k,v[f])
           skip = True
    if not skip:
       print "class %s : public opencraft_packet {" % k
       print "  public:"
       print "    %s(%s);" % (k,','.join(params))
       for p in params:
           print "    %s;" % p
       print "};"
print "}"
